| ğŸ§  Algorithm           | ğŸ’¬ Definition (Interview-Ready)                                                                                                | â±ï¸ Time Complexity                                                    | ğŸ’¾ Space                       | âš–ï¸ Stable?                       | ğŸ§© Key Idea / Notes                                  |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------- | ------------------------------ | -------------------------------- | ---------------------------------------------------- |
| **1ï¸âƒ£ Bubble Sort**    | Repeatedly compares adjacent elements and swaps them if they are in the wrong order â€” largest elements â€œbubble upâ€ to the end. | Best: **O(n)** (already sorted)<br>Avg: **O(nÂ²)**<br>Worst: **O(nÂ²)** | **O(1)**                       | âœ… Yes                            | Simple but inefficient for large datasets.           |
| **2ï¸âƒ£ Selection Sort** | Repeatedly finds the smallest (or largest) element and places it at the correct position in the sorted part of the array.      | Best: **O(nÂ²)**<br>Avg: **O(nÂ²)**<br>Worst: **O(nÂ²)**                 | **O(1)**                       | âŒ No                             | Minimizes swaps, but still quadratic time.           |
| **3ï¸âƒ£ Insertion Sort** | Builds the sorted array one element at a time by inserting each new element into its correct position.                         | Best: **O(n)**<br>Avg: **O(nÂ²)**<br>Worst: **O(nÂ²)**                  | **O(1)**                       | âœ… Yes                            | Efficient for small or nearly sorted data.           |
| **4ï¸âƒ£ Merge Sort**     | Uses Divide and Conquer: divides array into halves, sorts them recursively, then merges sorted halves.                         | Best: **O(n log n)**<br>Avg: **O(n log n)**<br>Worst: **O(n log n)**  | **O(n)**                       | âœ… Yes                            | Stable, fast, but uses extra space.                  |
| **5ï¸âƒ£ Quick Sort**     | Picks a pivot element, partitions array around pivot (smaller on left, larger on right), and recursively sorts both parts.     | Best: **O(n log n)**<br>Avg: **O(n log n)**<br>Worst: **O(nÂ²)**       | **O(log n)** (recursive stack) | âŒ No (depends on implementation) | Faster in practice; in-place; Divide and Conquer.    |
| **6ï¸âƒ£ Counting Sort**  | Non-comparison sort: counts occurrences of each unique value and reconstructs sorted array.                                    | **O(n + k)**                                                          | **O(n + k)**                   | âœ… Yes                            | Works for integers within a known range (0â€“k).       |
| **7ï¸âƒ£ Radix Sort**     | Sorts numbers digit by digit using a stable sub-sort (like Counting Sort).                                                     | **O(d Ã— (n + k))** (d = digits)                                       | **O(n + k)**                   | âœ… Yes                            | Works for integers; efficient for fixed-length keys. |
